# -*- coding: utf-8 -*-
"""MilvusDB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tEiVw2W_0kNnW95JARGvfLDcSCMlslDX
"""

!pip install --upgrade pip

!pip install -U pymilvus

!pip uninstall numpy -y
!pip install numpy==1.24.1

!pip install milvus-lite

!pip install --upgrade pymilvus



from pymilvus import MilvusClient, FieldSchema, CollectionSchema, DataType, Collection, connections, utility
from pymilvus import model
import re
import json
import milvus_lite
from collections import defaultdict
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

file_path = '/content/drive/MyDrive/text_data.txt'  # Replace with your actual file path
with open(file_path, 'r', encoding='utf-8') as file:
    content = file.readlines()

client= MilvusClient("mulvis_demo.db")

connections.connect(uri="milvus_demo.db")

def process_metadata(text):
    # Remove the first two lines as they don't contain relevant data
    content = content[2:]

    # Initialize dictionary to store metadata
    metadata = {
        "Book": [],
        "Author(s)": [],
        "Original language": [],
        "First published": [],
        "Approximate sales in millions": [],
        "Genre": []
    }

    # Iterate over each line to extract metadata
    for line in content:
        line = line.strip().split(",")

        # Handle special cases where the book title or genre may contain commas and quotes
        if line[0].startswith('"'):
            title_end_idx = next(i for i, val in enumerate(line) if val.endswith('"'))
            title = ','.join(line[:title_end_idx + 1]).strip('"')
            rest = line[title_end_idx + 1:]
        else:
            title, rest = line[0], line[1:]

        # Ensure we have enough columns in the rest list
        if len(rest) < 4:
            continue

        if len(rest) > 1 and rest[1].startswith('"'):
            genre_end_idx = next(i for i, val in enumerate(rest) if val.endswith('"'))
            genre = ','.join(rest[1:genre_end_idx + 1]).strip('"')
            rest = [rest[0]] + [genre] + rest[genre_end_idx + 1:]

        if len(rest) < 5:
            continue

        book = title.strip()
        author = rest[0].strip()
        language = rest[1].strip()
        published = rest[2].strip()
        sales = rest[3].strip()
        genre = rest[4].strip()

        # Append data to metadata dictionary
        metadata["Book"].append(book)
        metadata["Author(s)"].append(author)
        metadata["Original language"].append(language)
        metadata["First published"].append(published)
        metadata["Approximate sales in millions"].append(sales)
        metadata["Genre"].append(genre)

    return metadata

metadata_dict = process_metadata(content)
print(metadata_dict)

text=["Diagnosis: AI algorithms, especially those using machine learning and deep learning, are highly effective in diagnosing diseases from medical imaging such as X-rays, MRIs, and CT scans. They can identify patterns and anomalies that may be missed by human eyes, improving early detection of conditions like cancer, heart disease, and neurological disorders. Amaan. 21",
"Precision Medicine: AI enables the analysis of large datasets of patient information to tailor treatments to individual genetic profiles and health histories. This approach enhances the effectiveness of treatments and minimizes adverse effects, paving the way for precision medicine. Huzan. 21",
"Predictive Analytics: AI can predict patient outcomes by analyzing data from electronic health records (EHRs). Predictive models can foresee disease outbreaks, patient readmissions, and potential complications, helping healthcare providers to take proactive measures. Ahmad. 18",
"Surgical Assistance: AI-powered surgical robots assist surgeons in performing delicate procedures with higher precision, control, and flexibility. These robots can minimize human error, reduce recovery times, and improve overall surgical outcomes. Hasan. 23",
"Patient Engagement: AI-driven chatbots and virtual assistants provide patients with instant medical advice, appointment scheduling, medication reminders, and symptom checks. They enhance patient engagement and improve the efficiency of healthcare services. Irfan. 30",
"Drug Discovery: AI accelerates the drug discovery process by analyzing vast amounts of data to identify potential drug candidates and predict their efficacy. This reduces the time and cost associated with bringing new drugs to market. Haseeb. 10",
"Administrative Automation: AI automates administrative tasks such as billing, coding, and managing patient records, allowing healthcare professionals to focus more on patient care. This increases operational efficiency and reduces administrative burdens. Umer. 20",
"Clinical Decision Support: AI systems assist healthcare providers in making informed clinical decisions by analyzing patient data and providing evidence-based recommendations. This support enhances diagnostic accuracy and treatment planning. Fatima. 24",
"Remote Monitoring: AI technologies facilitate remote patient monitoring through wearable devices and telemedicine platforms. These systems can track vital signs, detect abnormalities, and provide real-time feedback to healthcare providers, improving patient care management. Musa. 5",
"Mental Health: AI applications in mental health include providing therapy through chatbots, detecting mental health conditions through speech and behavior analysis, and offering personalized support to patients with mental health issues. These tools can supplement traditional mental health services and make them more accessible. Umair. 40"]

def extract_metadata(text):
    pattern = re.compile(r'^(.*?): (.*)\. (\w+)\. (\d+)$')
    metadata = {}
    for entry in text:
        match = pattern.match(entry)
        if match:
            category, description, name, age = match.groups()
            metadata_entry = {
                'category': category.strip(),
                'description': description.strip(),
                'name': name.strip(),
                'age': int(age.strip())
            }
            metadata[f"entry{len(metadata) + 1}"] = metadata_entry
    return metadata

metadata = extract_metadata(text)
for key, value in metadata.items():
    print(f"{key}: {value}\n")

!pip install "pymilvus[model]"

embedding_fn=model.DefaultEmbeddingFunction()

vector=embedding_fn.encode_documents(text)

#print(vector)

sub=["entry1", "entry2", "entry3", "entry4", "entry5", "entry6", "entry7", "entry8", "entry9", "entry10"]
data = [
    {
        "id": i,
        "vector": vector[i],
        "text": text[i],
        "name": metadata[sub[i]]['name'],
        "age": metadata[sub[i]]['age'],
        "category": metadata[sub[i]]['category'],
        "description": metadata[sub[i]]['description'],
        "metadata": metadata.get(sub[i], {})
    }
    for i in range(len(vector))
]

print(data)

if client.has_collection(collection_name="milvus_collection"):
    client.drop_collection(collection_name="milvus_collection")
client.create_collection(
    collection_name="milvus_collection",
    dimension=768
)

print("Data has", len(data), "entities, each with fields: ", list(data[0].keys()))
print("Vector dim:", len(data[0]["vector"]))

db_insert = client.insert(collection_name="milvus_collection", data=data)
print(db_insert)

print(db_insert['ids'])

client.has_collection("milvus_collection")



query="Amaan"
query_vector=embedding_fn.encode_documents([query])
print(query_vector)



value={
    'logical_op1': 'or',
    'logical_op2': 'and',
    'operator1': '==',
    'operator2': '>',
    'operator3': '<',
    'field': ['category', 'name', 'age'],
    'category1': 'Drug Discovery',
    'name1': 'Fatima',
    'category2': 'Mental Health',
    'name2': 'Umair',
    'min_age': 23,
    'max_age': 41
}

def create_filter_conditions():
    # Example dynamic inputs (this can be replaced by actual dynamic inputs)
    main_condition = [
        {
            'logical_operator': value['logical_op1'],
            'conditions': [
                {
                    'logical_operator': value['logical_op2'],
                    'conditions': [
                        {'field': value['field'][0], 'operator': value['operator1'], 'value': value['category1']},
                        {'field': value['field'][1], 'operator': value['operator1'], 'value': value['name1']}
                    ]
                },
                {
                    'logical_operator': value['logical_op2'],
                    'conditions': [
                        {'field': value['field'][0], 'operator': value['operator1'], 'value': value['category2']},
                        {'field': value['field'][1], 'operator': value['operator1'], 'value': value['name2']}
                    ]
                }
            ]
        },
        {
            'logical_operator': value['logical_op2'],
            'conditions': [
                {'field': value['field'][2], 'operator': value['operator2'], 'value': value['min_age']},
                {'field': value['field'][2], 'operator': value['operator3'], 'value': value['max_age']},
            ]
        }
    ]

    # The outermost logical operator
    logical_operator = value['logical_op2']

    # Construct the filters dictionary
    filters = {
        'logical_operator': logical_operator,
        'conditions': main_condition
    }

    return filters



def build_expression(condition):
    if 'logical_operator' in condition:
        sub_conditions = condition['conditions']
        sub_expressions = [build_expression(sub) for sub in sub_conditions]
        return f" {condition['logical_operator']} ".join(sub_expressions)
    else:
        field = condition['field']
        operator = condition['operator']
        value = condition['value']
        if isinstance(value, str):
            value = f"'{value}'"
        return f"metadata['{field}'] {operator} {value}"

def filter_expression(filters):
      return build_expression(filters)

filters = create_filter_conditions()

filter_expr = filter_expression(filters)

res = client.search(
      collection_name="milvus_collection",  # target collection
      data=query_vector, # query vectors
      limit=5,  # number of returned entities
      metric_type="COSINE",
      filter = filter_expr,
      params={"nprobe":10},# search parameter
      output_fields=["name", "age", "category"], # specifies fields to be returned
)
for i in range(len(res)):
  for j in range(len(res[i])):
    print(res[i][j])

