# -*- coding: utf-8 -*-
"""RAG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19kQnvDe3IDN3G9v2WfZWhE0Zj0PCQweg
"""

!pip install --upgrade transformers

!pip install sentence_transformers

import transformers
import faiss
import re
import numpy as np
from transformers import pipeline
from sentence_transformers import SentenceTransformer, util
from transformers import AutoTokenizer, AutoModelForSequenceClassification, AutoModelForCausalLM

Model = SentenceTransformer('all-MiniLM-L6-v2')

!pip install faiss-cpu

text = "/content/drive/MyDrive/inputFile.txt"
with open(text, "r", encoding="utf-8") as f:
    text_data = f.readlines()

embeddings = Model.encode(text_data)
embeddings_np = np.array(embeddings)

d = embeddings_np.shape[1]  # Dimensionality of the embeddings
index = faiss.IndexFlatIP(d)  # Assuming cosine distance metric for similarity search

# Add embeddings to FAISS index
index.add(embeddings_np)

faiss.write_index(index, "/content/drive/MyDrive/indices.faiss")

!pip install pipeline

pipe = pipeline("text2text-generation", model="MBZUAI/LaMini-Flan-T5-248M")

def query_text(input_query, model, index, texts, k):
    # Retrieve the corresponding texts based on indices from FAISS
    query_embedding = model.encode([input_query])[0]

    # Perform a search using the FAISS index
    print(index)
    D, I = index.search(np.expand_dims(query_embedding, axis=0), k)
    print(f"D: {D}") #floating point values(distance of neighbour from query)
    print(f"I: {I}") #integer values(index of neighbour)
    print(f"I[0]: {I[0]}")
    # Check if I is not empty and index is in range
    closest_text = []
    if len(I[0]):
        for idx in I[0]: #having the single closest text is better as it gives way more precise result, but increasing k give irrelevent info
            if 0 <= idx < len(texts):
                closest_text.append(texts[idx])# Retrieve the closest text based on index
    else:
        closest_text = ""  # Handle the case where there's no closest text
    threshold=0.55


    return closest_text

def generate_text_completion(query, closest_text, pipe):
    # Encode the input query using FAISS
    if closest_text:
        closest_text_str=" ".join(closest_text)  # Ensure closest_text is not empty or whitespace
        max_length = len(closest_text_str)
        #max_length = max(max_length, 50)  # Adjust minimum max_length as needed
        max_length = max(max_length, 50)
        # Generate text completion using T5 with closest_text as input
        result = pipe(closest_text_str, query, max_length=max_length)

        generated_text = result[0]['generated_text']
    else:
        generated_text = "Warning: No valid input text found."  # Handle case where closest_text is empty

    return generated_text

l.
query = "Describe how the development of the Dirac equation led to the prediction of antimatter."

top_k=5
closest_text = query_text(query, Model, index, text_data, top_k)

generated_text=generate_text_completion(query, closest_text, pipe)
print(f"Input query: {query}\n")
for _ in range(len(closest_text)):
  print(f"Closest text: {closest_text[_]}\n")

print(f"Generated completion: \n{generated_text}")